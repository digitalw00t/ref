#!/usr/bin/env python3
# filename : ref
# author : draeician (July 22, 2023)
# purpose : to allow for fast cli recording from the command line for later reference

import readline
import os
import re
import sys
import requests
import argparse
import warnings
from datetime import datetime
from urllib.parse import urlparse, parse_qs
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import logging

import urllib3
import chardet
import charset_normalizer
from bs4 import BeautifulSoup
from dotenv import load_dotenv, set_key

urllib3.__version__ = '2.0.4'
chardet.__version__ = '5.2.0'
charset_normalizer.__version__ = '3.2.0'

__VERSION__ = "v1.4.0"

# Filter out the RequestsDependencyWarning
warnings.filterwarnings("ignore", category=DeprecationWarning, module="urllib3")

# Adjust the following line to point to the actual location of your .env file
env_path = os.path.join(os.path.expanduser("~"), '.env')
load_dotenv(dotenv_path=env_path)

YOUTUBE_API_SERVICE_NAME = 'youtube'
YOUTUBE_API_VERSION = 'v3'

# Set up logging
logging.basicConfig(filename='ref.log', level=logging.DEBUG, format='%(asctime)s %(levelname)s:%(message)s')

def check_integrity():
    errors = []

    with open(UNIFIED, "r") as file:
        for line_number, line in enumerate(file, start=1):
            if not re.match(r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\|\[.*\]\(.*\)\|\(.*\)\|.*\|(YouTube|General)\n$', line):
                expected_line = f'{datetime.now().isoformat()}|[URL]|(Title)|Source|(YouTube|General)'
                errors.append((f"references.md", line_number, line.strip(), expected_line))

    return errors

def set_developer_key():
    key = input("Please enter your YOUTUBE_API_KEY: ")
    os.environ['YOUTUBE_API_KEY'] = key
    set_key(env_path, 'YOUTUBE_API_KEY', key)
    print("YOUTUBE_API_KEY set successfully!")

DEVELOPER_KEY = os.getenv('YOUTUBE_API_KEY')

if DEVELOPER_KEY is None:
    print('Error: YOUTUBE_API_KEY is not set in .env file or shell environment.')
    choice = input('Would you like to set it now? (yes/no): ')

    if choice.lower() == 'yes':
        set_developer_key()
else:
    if os.getenv('DEBUG') == 'True':
        print('YOUTUBE_API_KEY is set.')

BASE = os.path.expanduser("~/")
UNIFIED = os.path.join(BASE, "references", "references.md")

def get_youtube_data(url: str) -> tuple:
    youtube = build(YOUTUBE_API_SERVICE_NAME, YOUTUBE_API_VERSION, developerKey=DEVELOPER_KEY)
    video_id = parse_qs(urlparse(url).query).get('v')
    if video_id:
        video_id = video_id[0]
    else:
        raise ValueError("Invalid YouTube URL")

    video_response = youtube.videos().list(part='snippet', id=video_id).execute()
    video_data = video_response['items'][0]['snippet']
    return video_id, video_data['title'], video_data['channelTitle']

def ensure_path_exists(file_path: str):
    directory = os.path.dirname(file_path)
    if not os.path.exists(directory):
        os.makedirs(directory)
    if not os.path.exists(file_path):
        open(file_path, 'w').close()

def append_to_file(file_path: str, line: str) -> None:
    ensure_path_exists(file_path)
    with open(file_path, "a") as f:
        f.write(line)
        f.flush()
        os.fsync(f.fileno())

def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Add URL to markdown files.")
    parser.add_argument("url", nargs='?', default=None, help="URL to be added.")
    parser.add_argument("-f", "--force", action="store_true", help="Force addition even if URL already exists.")
    parser.add_argument("-e", "--edit", action="store_true", help="Open markdown file for editing.")
    parser.add_argument("-d", "--debug", action="store_true", help="Print debug information.")
    parser.add_argument("--integrity", action="store_true", help="Check the integrity of log files.")
    parser.add_argument("--version", action="version", version=f"%(prog)s {__VERSION__}") 
    args = parser.parse_args()

    if args.edit:
        os.system(f"vim {UNIFIED}")
        sys.exit()

    if args.url:
        args.url = args.url.replace('&', '\\&')

    return args

def url_exists_in_file(url: str, file_path: str) -> bool:
    pattern = re.escape(url)
    with open(file_path, "r") as f:
        for line in f:
            if re.search(pattern, line):
                return True
    return False

def get_channel_name(url: str) -> str:
    parsed_url = urlparse(url)
    channel_path = parsed_url.path.rstrip('/')
    channel_name = channel_path.split('/')[-1]
    return channel_name

def get_title_from_url(url: str) -> str:
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36'
    }
    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        soup = BeautifulSoup(response.content, 'html.parser')
        title = soup.title.string.strip() if soup.title and soup.title.string else "No title found"
        return title
    except requests.exceptions.RequestException as e:
        logging.error(f"Error fetching title: {e}")
        return f"Error fetching title: {e}"
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")
        return f"An unexpected error occurred: {e}"

def process_url(url: str, force: bool) -> None:
    logging.debug(f"Processing URL: {url}")
    if "youtube.com" in url:
        try:
            video_id, title, uploader = get_youtube_data(url)
            title = re.sub('[^0-9a-zA-Z]+', ' ', title).strip()
            video_url = f"https://www.youtube.com/watch?v={video_id}"
            if url_exists_in_file(video_url, UNIFIED):
                print(f"Error: Video URL {video_url} already recorded.")
                logging.warning(f"Duplicate URL: {video_url}")
            else:
                append_to_file(UNIFIED, f"{datetime.now().isoformat()}|[{video_url}]|({title})|{uploader}|YouTube\n")
                print(f"{datetime.now().isoformat()}|[{video_url}]|({title})|{uploader}|YouTube")
                logging.info(f"Added URL: {video_url}")
        except ValueError as e:
            print(f"Error: {e}")
            logging.error(f"Invalid YouTube URL: {e}")
    else:
        title = get_title_from_url(url)
        if title and not title.startswith("Error"):
            if url_exists_in_file(url, UNIFIED):
                print(f"Error: URL {url} already recorded.")
                logging.warning(f"Duplicate URL: {url}")
            else:
                append_to_file(UNIFIED, f"{datetime.now().isoformat()}|[{url}]|({title})|General|General\n")
                print(f"{datetime.now().isoformat()}|[{url}]|({title})|General|General")
                logging.info(f"Added URL: {url}")
        else:
            print("Invalid URL")
            logging.error("Invalid URL")

def main() -> None:
    ensure_path_exists(UNIFIED)

    try:
        args = parse_arguments()

        print(f"ARGS: {args.url}")

        if args.integrity:
            integrity_errors = check_integrity()
            if integrity_errors:
                print("Integrity check failed:")
                for error in integrity_errors:
                    file_name, line_number, line_contents = error
                    print(f"{file_name} line {line_number}: {line_contents}")
            else:
                print("Integrity check passed. Log files are formatted correctly.")
        elif args.url:
            process_url(args.url, args.force)
        else:
            while True:
                try:
                    url = input("Enter a URL to record (or press Ctrl+C to quit): ")
                    force = False
                    process_url(url, force)
                except Exception as e:
                    print(f"An error occurred: {e}")
                    logging.error(f"An error occurred: {e}")
    except KeyboardInterrupt:
        print("\nExiting...")
        sys.exit(0)

if __name__ == "__main__":
    main()
