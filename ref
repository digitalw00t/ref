#!/usr/bin/env python3
# filename : ref
# author : draeician (July 22, 2023)
# purpose : to allow for fast cli recording from the command line for later reference

import readline
import os
import re
import sys
import requests
import argparse
import warnings
from datetime import datetime
from urllib.parse import urlparse, parse_qs
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import logging

import urllib3
import chardet
import charset_normalizer
from bs4 import BeautifulSoup
from dotenv import load_dotenv, set_key

urllib3.__version__ = '2.0.4'
chardet.__version__ = '5.2.0'
charset_normalizer.__version__ = '3.2.0'

__VERSION__ = "v1.4.1"

# Filter out the RequestsDependencyWarning
warnings.filterwarnings("ignore", category=DeprecationWarning, module="urllib3")

# Adjust the following line to point to the actual location of your .env file
env_path = os.path.join(os.path.expanduser("~"), '.env')
load_dotenv(dotenv_path=env_path)

YOUTUBE_API_SERVICE_NAME = 'youtube'
YOUTUBE_API_VERSION = 'v3'

# Set up logging
#logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(levelname)s:%(message)s')

DEVELOPER_KEY = os.getenv('YOUTUBE_API_KEY')
BASE = os.path.expanduser("~/")
UNIFIED = os.path.join(BASE, "references", "references.md")

def check_integrity():
    errors = []
    with open(UNIFIED, "r") as file:
        for line_number, line in enumerate(file, start=1):
            if not re.match(r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\|\[.*\]\(.*\)\|\(.*\)\|.*\|(YouTube|General)\n$', line):
                expected_line = f'{datetime.now().isoformat()}|[URL]|(Title)|Source|(YouTube|General)'
                errors.append((f"references.md", line_number, line.strip(), expected_line))
    return errors

def set_developer_key():
    key = input("Please enter your YOUTUBE_API_KEY: ")
    os.environ['YOUTUBE_API_KEY'] = key
    set_key(env_path, 'YOUTUBE_API_KEY', key)
    print("YOUTUBE_API_KEY set successfully!")

if DEVELOPER_KEY is None:
    print('Error: YOUTUBE_API_KEY is not set in .env file or shell environment.')
    choice = input('Would you like to set it now? (yes/no): ')
    if choice.lower() == 'yes':
        set_developer_key()
else:
    if os.getenv('DEBUG') == 'True':
        print('YOUTUBE_API_KEY is set.')

def get_youtube_data(url: str) -> tuple:
    youtube = build(YOUTUBE_API_SERVICE_NAME, YOUTUBE_API_VERSION, developerKey=DEVELOPER_KEY)
    parsed_url = urlparse(url)
    query_params = parse_qs(parsed_url.query)
    if 'list' in query_params:
        return get_youtube_playlist_data(query_params['list'][0], youtube)
    video_id = query_params.get('v')
    if video_id:
        video_id = video_id[0]
    else:
        raise ValueError("Invalid YouTube URL")
    video_response = youtube.videos().list(part='snippet', id=video_id).execute()
    video_data = video_response['items'][0]['snippet']
    return video_id, video_data['title'], video_data['channelTitle']

def get_youtube_playlist_data(playlist_id: str, youtube) -> list:
    video_details = []
    next_page_token = None
    while True:
        playlist_response = youtube.playlistItems().list(
            part='snippet',
            maxResults=50,
            playlistId=playlist_id,
            pageToken=next_page_token
        ).execute()
        for item in playlist_response['items']:
            video_id = item['snippet']['resourceId']['videoId']
            title = item['snippet']['title']
            uploader = item['snippet']['channelTitle']
            video_details.append((video_id, title, uploader))
        next_page_token = playlist_response.get('nextPageToken')
        if not next_page_token:
            break
    return video_details

def ensure_path_exists(file_path: str):
    directory = os.path.dirname(file_path)
    if not os.path.exists(directory):
        os.makedirs(directory)
    if not os.path.exists(file_path):
        open(file_path, 'w').close()

def append_to_file(file_path: str, line: str) -> None:
    ensure_path_exists(file_path)
    with open(file_path, "a") as f:
        f.write(line)
        f.flush()
        os.fsync(f.fileno())

def parse_arguments() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Add URL to markdown files.")
    parser.add_argument("url", nargs='?', default=None, help="URL to be added.")
    parser.add_argument("-f", "--force", action="store_true", help="Force addition even if URL already exists.")
    parser.add_argument("-e", "--edit", action="store_true", help="Open markdown file for editing.")
    parser.add_argument("-d", "--debug", action="store_true", help="Print debug information.")
    parser.add_argument("--integrity", action="store_true", help="Check the integrity of log files.")
    parser.add_argument("-b", "--backup", action="store_true", help="Create a backup of the references.md file.")
    parser.add_argument("--version", action="version", version=f"%(prog)s {__VERSION__}") 
    args = parser.parse_args()
    if args.edit:
        os.system(f"vim {UNIFIED}")
        sys.exit()
    if args.url:
        args.url = args.url.replace('&', '\\&')
    return args

def url_exists_in_file(url: str, file_path: str) -> bool:
    pattern = re.escape(url)
    with open(file_path, "r") as f:
        for line in f:
            if re.search(pattern, line):
                return True
    return False

def get_title_from_url(url: str) -> str:
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36'
    }
    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        soup = BeautifulSoup(response.content, 'html.parser')
        title = soup.title.string.strip() if soup.title and soup.title.string else "No title found"
        return title
    except requests.exceptions.RequestException as e:
        logging.error(f"Error fetching title: {e}")
        return "Dead link"
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")
        return "Unexpected error"

def process_url(url: str, force: bool) -> None:
    logging.debug(f"Processing URL: {url}")
    if "youtube.com" in url:
        try:
            result = get_youtube_data(url)
            if isinstance(result, list):  # Playlist
                for video_id, title, uploader in result:
                    title = re.sub('[^0-9a-zA-Z]+', ' ', title).strip()
                    video_url = f"https://www.youtube.com/watch?v={video_id}"
                    if not url_exists_in_file(video_url, UNIFIED):
                        append_to_file(UNIFIED, f"{datetime.now().isoformat()}|[{video_url}]|({title})|{uploader}|YouTube\n")
                        print(f"{datetime.now().isoformat()}|[{video_url}]|({title})|{uploader}|YouTube")
                        logging.info(f"Added URL: {video_url}")
                    else:
                        print(f"Error: URL {video_url} already recorded.")
                        logging.warning(f"Duplicate URL: {video_url}")
            else:  # Single Video
                video_id, title, uploader = result
                title = re.sub('[^0-9a-zA-Z]+', ' ', title).strip()
                video_url = f"https://www.youtube.com/watch?v={video_id}"
                if not url_exists_in_file(video_url, UNIFIED):
                    append_to_file(UNIFIED, f"{datetime.now().isoformat()}|[{video_url}]|({title})|{uploader}|YouTube\n")
                    print(f"{datetime.now().isoformat()}|[{video_url}]|({title})|{uploader}|YouTube")
                    logging.info(f"Added URL: {video_url}")
                else:
                    print(f"Error: URL {video_url} already recorded.")
                    logging.warning(f"Duplicate URL: {video_url}")
        except ValueError as e:
            print(f"Error: {e}")
            logging.error(f"Invalid YouTube URL: {e}")
    else:
        title = get_title_from_url(url)
        logging.debug(f"Fetched title: {title}")
        if title == "Dead link":
            print(f"Error: The URL {url} is a dead link.")
            logging.error(f"Dead link detected: {url}")
        elif title.startswith("Unexpected error"):
            print("Error: An unexpected error occurred.")
            logging.error(f"Unexpected error with URL: {url}")
        elif title and not title.startswith("Error"):
            if url_exists_in_file(url, UNIFIED):
                print(f"Error: URL {url} already recorded.")
                logging.warning(f"Duplicate URL: {url}")
            else:
                append_to_file(UNIFIED, f"{datetime.now().isoformat()}|[{url}]|({title})|General|General\n")
                print(f"{datetime.now().isoformat()}|[{url}]|({title})|General|General")
                logging.info(f"Added URL: {url}")
        else:
            print("Invalid URL")
            logging.error(f"Invalid URL: {url} with title: {title}")

def create_backup(file_path: str) -> None:
    timestamp = datetime.now().strftime("%Y%m%dT%H%M%S")
    backup_file_path = f"{os.path.dirname(file_path)}/{timestamp}_{os.path.basename(file_path)}"
    try:
        with open(file_path, 'r') as original_file:
            with open(backup_file_path, 'w') as backup_file:
                backup_file.write(original_file.read())
        print(f"Backup created: {backup_file_path}")
        logging.info(f"Backup created: {backup_file_path}")
    except Exception as e:
        print(f"Error creating backup: {e}")
        logging.error(f"Error creating backup: {e}")

def main() -> None:
    ensure_path_exists(UNIFIED)
    try:
        args = parse_arguments()
        if args.integrity:
            integrity_errors = check_integrity()
            if integrity_errors:
                print("Integrity check failed:")
                for error in integrity_errors:
                    file_name, line_number, line_contents, expected_line = error
                    print(f"{file_name} line {line_number}: {line_contents}\nExpected: {expected_line}")
            else:
                print("Integrity check passed. Log files are formatted correctly.")
        elif args.backup:
            create_backup(UNIFIED)
        elif args.url:
            process_url(args.url, args.force)
        else:
            while True:
                try:
                    url = input("Enter a URL to record (or press Ctrl+C to quit): ")
                    force = False
                    process_url(url, force)
                except Exception as e:
                    print(f"An error occurred: {e}")
                    logging.error(f"An error occurred: {e}")
    except KeyboardInterrupt:
        print("\nExiting...")
        sys.exit(0)

if __name__ == "__main__":
    main()
